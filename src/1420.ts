// 1421. Build Array Where You Can Find The Maximum Exactly K Comparisons
// You are given three integers n, m and k. Consider the following algorithm to find the maximum element of an array of positive integers:
// You should build the array arr which has the following properties:
// arr has exactly n integers.
// 1 <= arr[i] <= m where (0 <= i < n).
// After applying the mentioned algorithm to arr, the value search_cost is equal to k.
// Return the number of ways to build the array arr under the mentioned conditions. As the answer may grow large, the answer must be computed modulo 109 + 7.

// Example 1:
// Input: n = 2, m = 3, k = 1
// Output: 6
// Explanation: The possible arrays are [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]

// Example 2:
// Input: n = 5, m = 2, k = 3
// Output: 0
// Explanation: There are no possible arrays that satisfy the mentioned conditions.

// Example 3:
// Input: n = 9, m = 1, k = 1
// Output: 1
// Explanation: The only possible array is [1, 1, 1, 1, 1, 1, 1, 1, 1]

// Constraints:
// 1 <= n <= 50
// 1 <= m <= 100
// 0 <= k <= n

// n=2,m=5,k=2
// [1 2] 3 4 5
// [1] 2 [3] 4 5
// [1] 2 3 [4] 5
// [1] 2 3 4 [5]
// 4
// 1 [2 3] 4 5
// 1 [2] 3 [4] 5
// 1 [2] 3 4 [5]
// 3
// 1 2 [3 4] 5
// 1 2 [3] 4 [5]
// 2
// 1 2 3 [4 5]
// 1
// 1+2+3+4=10 (possible n*m)

// n=2,m=6,k=2
// 1 2
// 1 3
// 1 4
// 1 5
// 1 6
// 5
// 2 3
// 2 4
// 2 5
// 2 6
// 4
// 3 4
// 3 5
// 3 6
// 3
// 4 5
// 4 6
// 2
// 5 6
// 1
// 1+2+3+4+5=15
// see https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF
// sum of all good arrays is (n(n+1))/2 where n is m-1
// nth element of triangular number sequence

// let's test it for n=3,m=6,k=3
// 1 2 3
// 1 2 4
// 1 2 5
// 1 2 6
// 4
// 1 3 4
// 1 3 5
// 1 3 6
// 3
// 1 4 5
// 1 4 6
// 2
// 1 5 6
// 1
// total 10

// 2 3 4
// 2 3 5
// 2 3 6
// 3
// 2 4 5
// 2 4 6
// 2
// 2 5 6
// 1
// total 6

// 3 4 5
// 3 4 6
// 2
// 3 5 6
// 1
// total 3

// 4 5 6
// 1
// total 1

// overall 10+6+3+1=20
// nth element of tetrahedral number sequence

// let's see n=3,m=7,k=3
// 1 2 3
// 1 2 4
// 1 2 5
// 1 2 6
// 1 2 7
// 5
// 1 3 4
// 1 3 5
// 1 3 6
// 1 3 7
// 4
// ... 5+4+3+2+1=15
// 4+3+2+1=10
// 3+2+1=6
// 2+1=3
// 1
// (m-n)th element in Pascal's triangle on min(k,n)th row

// now about the rest...
// if k < n we should find the binomial coefficient of "k choose m" instead of "n choose m"
// now imagine we have k=3 and n=4 and m=4
// then we have these combinations:
// 1 2 3
// 1 2 4
// ...
// we expand each single combination by multiplying by ?

// 1 2 3 1
// 1 2 3 2
// 1 2 3 3
// 1 2 4 1
// 1 2 4 2
// 1 2 4 3
// 1 2 4 4
// 1 2 5 1
// 1 2 5 2
// 1 2 5 3
// 1 2 5 4
// 1 2 5 5
// 1 2 6 1
// 1 2 6 2
// 1 2 6 3
// 1 2 6 4
// 1 2 6 5
// 1 2 6 6
// 18
// 1 3 4 1
// 1 3 4 2
// 1 3 4 3
// 1 3 4 4
// 1 3 5 1
// 1 3 5 2
// 1 3 5 3
// 1 3 5 4
// 1 3 5 5
// 1 3 6 1
// 1 3 6 2
// 1 3 6 3
// 1 3 6 4
// 1 3 6 5
// 1 3 6 6
// 15
// 1 4 5 1
// 1 4 5 2
// 1 4 5 3
// 1 4 5 4
// 1 4 5 5
// 1 4 6 1
// 1 4 6 2
// 1 4 6 3
// 1 4 6 4
// 1 4 6 5
// 1 4 6 6
// 11
// 1 5 6 1
// 1 5 6 2
// 1 5 6 3
// 1 5 6 4
// 1 5 6 5
// 1 5 6 6
// 6
// total 10

// 2 3 4
// 2 3 5
// 2 3 6
// 3
// 2 4 5
// 2 4 6
// 2
// 2 5 6
// 1
// total 6

// 3 4 5
// 3 4 6
// 2
// 3 5 6
// 1
// total 3

// 4 5 6
// 1
// total 1

const logf = [
  0, 0, 0.6931471805599453, 1.791759469228055, 3.1780538303479458,
  4.787491742782046, 6.579251212010101, 8.525161361065415, 10.60460290274525,
  12.801827480081469, 15.104412573075516, 17.502307845873887,
  19.987214495661885, 22.552163853123425, 25.19122118273868, 27.89927138384089,
  30.671860106080672, 33.50507345013689, 36.39544520803305, 39.339884187199495,
  42.335616460753485, 45.38013889847691, 48.47118135183523, 51.60667556776438,
  54.78472939811232, 58.00360522298052, 61.261701761002, 64.55753862700634,
  67.88974313718154, 71.25703896716801, 74.65823634883016, 78.0922235533153,
  81.55795945611504, 85.05446701758152, 88.58082754219768, 92.1361756036871,
  95.7196945421432, 99.33061245478743, 102.96819861451381, 106.63176026064346,
  110.32063971475739, 114.0342117814617, 117.77188139974507, 121.53308151543864,
  125.3172711493569, 129.12393363912722, 132.95257503561632, 136.80272263732635,
  140.67392364823425, 144.5657439463449, 148.47776695177302, 152.40959258449735,
  156.3608363030788, 160.3311282166309, 164.32011226319517, 168.32744544842765,
  172.3527971391628, 176.39584840699735, 180.45629141754378, 184.53382886144948,
  188.6281734236716, 192.7390472878449, 196.86618167289, 201.00931639928152,
  205.1681994826412, 209.34258675253685, 213.53224149456327, 217.73693411395422,
  221.95644181913033, 226.1905483237276, 230.43904356577696, 234.70172344281826,
  238.97838956183432, 243.2688490029827, 247.57291409618688, 251.8904022097232,
  256.22113555000954, 260.5649409718632, 264.9216497985528, 269.2910976510198,
  273.6731242856937, 278.0675734403661, 282.4742926876304, 286.893133295427,
  291.3239500942703, 295.76660135076065, 300.22094864701415, 304.6868567656687,
  309.1641935801469, 313.65282994987905, 318.1526396202093, 322.66349912672615,
  327.1852877037752, 331.7178871969285, 336.26118197919845, 340.815058870799,
  345.37940706226686, 349.95411804077025, 354.5390855194408, 359.1342053695754,
  363.73937555556347,
]

const binomial = (n: number, k: number): number => {
  return Math.exp(logf[n] - logf[n - k] - logf[k])
}
export const numOfArrays = (n: number, m: number, k: number): number => {
  return Math.round(binomial(Math.min(n, k), m))
}
